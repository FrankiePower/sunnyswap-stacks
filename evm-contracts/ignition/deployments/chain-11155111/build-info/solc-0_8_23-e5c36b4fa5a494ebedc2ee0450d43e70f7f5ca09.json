{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_23-e5c36b4fa5a494ebedc2ee0450d43e70f7f5ca09",
  "solcVersion": "0.8.23",
  "solcLongVersion": "0.8.23+commit.f704f362",
  "userSourceNameMap": {
    "contracts/Resolver.sol": "project/contracts/Resolver.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "project/contracts/interfaces/IBaseEscrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Address } from \"../libraries/AddressLib.sol\";\n\nimport { Timelocks } from \"../libraries/TimelocksLib.sol\";\n\n/**\n * @title Base Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IBaseEscrow {\n    struct Immutables {\n        bytes32 orderHash;\n        bytes32 hashlock;  // Hash of the secret.\n        Address maker;\n        Address taker;\n        Address token;\n        uint256 amount;\n        uint256 safetyDeposit;\n        Timelocks timelocks;\n    }\n\n    /**\n     * @notice Emitted on escrow cancellation.\n     */\n    event EscrowCancelled();\n\n    /**\n     * @notice Emitted when funds are rescued.\n     * @param token The address of the token rescued. Zero address for native token.\n     * @param amount The amount of tokens rescued.\n     */\n    event FundsRescued(address token, uint256 amount);\n\n    /**\n     * @notice Emitted on successful withdrawal.\n     * @param secret The secret that unlocks the escrow.\n     */\n    event EscrowWithdrawal(bytes32 secret);\n\n    error InvalidCaller();\n    error InvalidImmutables();\n    error InvalidSecret();\n    error InvalidTime();\n    error NativeTokenSendingFailure();\n\n    /* solhint-disable func-name-mixedcase */\n    /// @notice Returns the delay for rescuing funds from the escrow.\n    function RESCUE_DELAY() external view returns (uint256);\n    /// @notice Returns the address of the factory that created the escrow.\n    function FACTORY() external view returns (address);\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @notice Withdraws funds to a predetermined recipient.\n     * @dev Withdrawal can only be made during the withdrawal period and with secret with hash matches the hashlock.\n     * The safety deposit is sent to the caller.\n     * @param secret The secret that unlocks the escrow.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function withdraw(bytes32 secret, Immutables calldata immutables) external;\n\n    /**\n     * @notice Cancels the escrow and returns tokens to a predetermined recipient.\n     * @dev The escrow can only be cancelled during the cancellation period.\n     * The safety deposit is sent to the caller.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function cancel(Immutables calldata immutables) external;\n\n    /**\n     * @notice Rescues funds from the escrow.\n     * @dev Funds can only be rescued by the taker after the rescue delay.\n     * @param token The address of the token to rescue. Zero address for native token.\n     * @param amount The amount of tokens to rescue.\n     * @param immutables The immutables of the escrow contract.\n     */\n    function rescueFunds(address token, uint256 amount, Immutables calldata immutables) external;\n}\n"
      },
      "project/contracts/interfaces/IEscrow.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title Escrow interface for cross-chain atomic swap.\n * @notice Interface implies locking funds initially and then unlocking them with verification of the secret presented.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrow is IBaseEscrow {\n    /// @notice Returns the bytecode hash of the proxy contract.\n    function PROXY_BYTECODE_HASH() external view returns (bytes32); // solhint-disable-line func-name-mixedcase\n}\n"
      },
      "project/contracts/interfaces/IEscrowFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { Address } from \"../libraries/AddressLib.sol\";\n\nimport { Timelocks } from \"../libraries/TimelocksLib.sol\";\n\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title Escrow Factory interface for cross-chain atomic swap.\n * @notice Interface to deploy escrow contracts for the destination chain and to get the deterministic address of escrow on destination chain.\n * @custom:security-contact security@1inch.io\n */\ninterface IEscrowFactory {\n    struct ExtraDataArgs {\n        bytes32 hashlockInfo; // Hash of the secret or the Merkle tree root if multiple fills are allowed\n        uint256 dstChainId;\n        Address dstToken;\n        uint256 deposits;\n        Timelocks timelocks;\n    }\n\n    struct DstImmutablesComplement {\n        Address maker;\n        uint256 amount;\n        Address token;\n        uint256 safetyDeposit;\n        uint256 chainId;\n    }\n\n    error InsufficientEscrowBalance();\n    error InvalidCreationTime();\n    error InvalidPartialFill();\n    error InvalidSecretsAmount();\n\n    /**\n     * @notice Emitted on EscrowDst deployment.\n     * @param escrow The address of the created escrow.\n     * @param hashlock The hash of the secret.\n     * @param taker The address of the taker.\n     * @param creator The address of who created the escrow (maker, resolver, etc).\n     * @param creatorType Type of creator: 0=Resolver, 1=Maker, 2=Taker, 3=Other\n     */\n    event DstEscrowCreated(\n        address escrow, \n        bytes32 hashlock, \n        Address taker,\n        address indexed creator,\n        uint8 creatorType\n    );\n\n    /* solhint-disable func-name-mixedcase */\n    /// @notice Returns the address of implementation on the destination chain.\n    function ESCROW_DST_IMPLEMENTATION() external view returns (address);\n    /* solhint-enable func-name-mixedcase */\n\n    /**\n     * @notice Creates a new escrow contract for taker on the destination chain.\n     * @dev The caller must send the safety deposit in the native token along with the function call\n     * and approve the destination token to be transferred to the created escrow.\n     * @param dstImmutables The immutables of the escrow contract that are used in deployment.\n     */\n    function createDstEscrow(IBaseEscrow.Immutables calldata dstImmutables) external payable;\n\n    /**\n     * @notice Returns the deterministic address of the destination escrow based on the salt.\n     * @param immutables The immutable arguments used to compute salt for escrow deployment.\n     * @return The computed address of the escrow.\n     */\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view returns (address);\n}\n"
      },
      "project/contracts/interfaces/ISTXEscrowFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Address } from \"../libraries/AddressLib.sol\";\nimport { IBaseEscrow } from \"./IBaseEscrow.sol\";\n\n/**\n * @title STX Escrow Factory interface for EVM-Stacks atomic swaps\n * @notice Interface for creating Stacks atomic swap escrows\n * @dev Supports both EVM→STACKS and STACKS→EVM swap directions\n * @custom:security-contact security@sunnyswap.io\n */\ninterface ISTXEscrowFactory {\n    \n    /// @notice Thrown when insufficient ETH is sent for escrow creation\n    error InsufficientEscrowBalance();\n\n    /**\n     * @notice Emitted when a source escrow is created (EVM→STACKS)\n     * @param escrow The address of the created source escrow\n     * @param hashlock The hash of the secret\n     * @param maker The address of the maker\n     * @param creator The address of who created the escrow\n     */\n    event SrcEscrowCreated(\n        address escrow, \n        bytes32 hashlock, \n        Address maker, \n        address indexed creator\n    );\n\n    /**\n     * @notice Emitted when a destination escrow is created (STACKS→EVM)\n     * @param escrow The address of the created destination escrow\n     * @param hashlock The hash of the secret\n     * @param taker The address of the taker\n     * @param creator The address of who created the escrow\n     */\n    event DstEscrowCreated(\n        address escrow, \n        bytes32 hashlock, \n        Address taker, \n        address indexed creator\n    );\n\n    /**\n     * @notice Creates a source escrow for EVM→STACKS swaps\n     * @dev Maker creates this escrow with EVM tokens, taker will provide Stacks\n     * @param immutables The escrow immutables including Stacks parameters\n     */\n    function createSrcEscrow(IBaseEscrow.Immutables calldata immutables) external payable;\n\n    /**\n     * @notice Creates a destination escrow for STACKS→EVM swaps\n     * @dev Taker creates this escrow with EVM tokens, maker will provide Stacks  \n     * @param immutables The escrow immutables including Stacks parameters\n     */\n    function createDstEscrow(IBaseEscrow.Immutables calldata immutables) external payable;\n\n    /**\n     * @notice Returns the deterministic address of a source escrow\n     * @param immutables The escrow immutables\n     * @return The computed address of the source escrow\n     */\n    function addressOfEscrowSrc(IBaseEscrow.Immutables calldata immutables) external view returns (address);\n\n    /**\n     * @notice Returns the deterministic address of a destination escrow\n     * @param immutables The escrow immutables\n     * @return The computed address of the destination escrow\n     */\n    function addressOfEscrowDst(IBaseEscrow.Immutables calldata immutables) external view returns (address);\n\n    /**\n     * @notice Returns the source escrow implementation address\n     * @return The address of the source escrow implementation\n     */\n    function STX_ESCROW_SRC_IMPLEMENTATION() external view returns (address);\n\n    /**\n     * @notice Returns the destination escrow implementation address\n     * @return The address of the destination escrow implementation\n     */\n    function STX_ESCROW_DST_IMPLEMENTATION() external view returns (address);\n} "
      },
      "project/contracts/libraries/AddressLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\n/**\n * @title Address type for 1inch contracts\n * @notice Utility library for Address type operations  \n */\n\ntype Address is uint256;\n\nlibrary AddressLib {\n    function get(Address addr) internal pure returns (address) {\n        return address(uint160(Address.unwrap(addr)));\n    }\n\n    function wrap(address addr) internal pure returns (Address) {\n        return Address.wrap(uint256(uint160(addr)));\n    }\n} "
      },
      "project/contracts/libraries/ImmutablesLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IBaseEscrow } from \"../interfaces/IBaseEscrow.sol\";\n\n/**\n * @title Library for escrow immutables.\n * @custom:security-contact security@1inch.io\n */\nlibrary ImmutablesLib {\n    uint256 internal constant ESCROW_IMMUTABLES_SIZE = 0x100;\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hash(IBaseEscrow.Immutables calldata immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, immutables, ESCROW_IMMUTABLES_SIZE)\n            ret := keccak256(ptr, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n\n    /**\n     * @notice Returns the hash of the immutables.\n     * @param immutables The immutables to hash.\n     * @return ret The computed hash.\n     */\n    function hashMem(IBaseEscrow.Immutables memory immutables) internal pure returns(bytes32 ret) {\n        assembly (\"memory-safe\") {\n            ret := keccak256(immutables, ESCROW_IMMUTABLES_SIZE)\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/TimelocksLib.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Timelocks for the destination chain plus the deployment timestamp.\n * Timelocks store the number of seconds from the time the contract is deployed to the start of a specific period.\n * For illustrative purposes, it is possible to describe timelocks by the structure:\n * struct DstTimelocks {\n *     uint256 withdrawal;\n *     uint256 publicWithdrawal;\n *     uint256 cancellation;\n * }\n *\n * withdrawal: Period when only the taker with a secret can withdraw tokens for maker (destination chain).\n * publicWithdrawal: Period when anyone with a secret can withdraw tokens for maker (destination chain).\n * cancellation: Period when escrow can only be cancelled by the taker.\n *\n * @custom:security-contact security@1inch.io\n */\ntype Timelocks is uint256;\n\n/**\n * @title Timelocks library for compact storage of timelocks in a uint256.\n */\nlibrary TimelocksLib {\n    enum Stage {\n        DstWithdrawal,\n        DstPublicWithdrawal,\n        DstCancellation\n    }\n\n    uint256 private constant _DEPLOYED_AT_MASK = 0xffffffff00000000000000000000000000000000000000000000000000000000;\n    uint256 private constant _DEPLOYED_AT_OFFSET = 224;\n\n    /**\n     * @notice Sets the Escrow deployment timestamp.\n     * @param timelocks The timelocks to set the deployment timestamp to.\n     * @param value The new Escrow deployment timestamp.\n     * @return The timelocks with the deployment timestamp set.\n     */\n    function setDeployedAt(Timelocks timelocks, uint256 value) internal pure returns (Timelocks) {\n        return Timelocks.wrap((Timelocks.unwrap(timelocks) & ~uint256(_DEPLOYED_AT_MASK)) | value << _DEPLOYED_AT_OFFSET);\n    }\n\n    /**\n     * @notice Returns the start of the rescue period.\n     * @param timelocks The timelocks to get the rescue delay from.\n     * @return The start of the rescue period.\n     */\n    function rescueStart(Timelocks timelocks, uint256 rescueDelay) internal pure returns (uint256) {\n        unchecked {\n            return rescueDelay + (Timelocks.unwrap(timelocks) >> _DEPLOYED_AT_OFFSET);\n        }\n    }\n\n    /**\n     * @notice Returns the timelock value for the given stage.\n     * @param timelocks The timelocks to get the value from.\n     * @param stage The stage to get the value for.\n     * @return The timelock value for the given stage.\n     */\n    function get(Timelocks timelocks, Stage stage) internal pure returns (uint256) {\n        uint256 data = Timelocks.unwrap(timelocks);\n        uint256 bitShift = uint256(stage) * 32;\n        // The maximum uint32 value will be reached in 2106.\n        return (data >> _DEPLOYED_AT_OFFSET) + uint32(data >> bitShift);\n    }\n}\n"
      },
      "project/contracts/Resolver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {IEscrowFactory} from \"./interfaces/IEscrowFactory.sol\";\nimport {ISTXEscrowFactory} from \"./interfaces/ISTXEscrowFactory.sol\";\nimport {IBaseEscrow} from \"./interfaces/IBaseEscrow.sol\";\nimport {IEscrow} from \"./interfaces/IEscrow.sol\";\nimport {TimelocksLib, Timelocks} from \"./libraries/TimelocksLib.sol\";\nimport {ImmutablesLib} from \"./libraries/ImmutablesLib.sol\";\nimport {Address} from \"./libraries/AddressLib.sol\";\n\n/**\n * @title Resolver contract for SunnySwap cross-chain swaps\n * @notice This contract acts as the automated market maker for STX ↔ EVM swaps\n * @dev The resolver bot owns this contract and uses it to:\n *      - Deploy counter-escrows\n *      - Claim tokens when secrets are revealed\n *      - Refund tokens on timeouts\n *\n * @custom:security-contact your@email.com\n */\ncontract Resolver is Ownable {\n    using ImmutablesLib for IBaseEscrow.Immutables;\n    using TimelocksLib for Timelocks;\n\n    error InvalidLength();\n    error LengthMismatch();\n    error InsufficientValue();\n\n    ISTXEscrowFactory private immutable _FACTORY;\n\n    /**\n     * @notice Emitted when a source escrow is deployed by the resolver\n     * @param escrow Address of the deployed escrow\n     * @param orderHash Unique identifier for the swap order\n     * @param hashlock SHA256 hash of the secret\n     */\n    event SrcEscrowDeployed(\n        address indexed escrow,\n        bytes32 indexed orderHash,\n        bytes32 hashlock\n    );\n\n    /**\n     * @notice Emitted when a destination escrow is deployed by the resolver\n     * @param escrow Address of the deployed escrow\n     * @param orderHash Unique identifier for the swap order\n     * @param hashlock SHA256 hash of the secret\n     */\n    event DstEscrowDeployed(\n        address indexed escrow,\n        bytes32 indexed orderHash,\n        bytes32 hashlock\n    );\n\n    /**\n     * @notice Emitted when resolver withdraws from an escrow\n     * @param escrow Address of the escrow\n     * @param secret The revealed preimage\n     */\n    event ResolverWithdraw(address indexed escrow, bytes32 secret);\n\n    /**\n     * @notice Emitted when resolver cancels an escrow\n     * @param escrow Address of the escrow\n     */\n    event ResolverCancel(address indexed escrow);\n\n    /**\n     * @notice Creates a new Resolver contract\n     * @param factoryAddress Address of the STXEscrowFactory\n     * @param initialOwner Address that will own this contract (resolver bot)\n     */\n    constructor(address factoryAddress, address initialOwner) Ownable(initialOwner) {\n        _FACTORY = ISTXEscrowFactory(factoryAddress);\n    }\n\n    /**\n     * @notice Allows contract to receive ETH\n     */\n    receive() external payable {} // solhint-disable-line no-empty-blocks\n\n    /**\n     * @notice Deploy a source escrow (EVM → STX direction)\n     * @dev Called by resolver bot when user initiates EVM → STX swap\n     * @param immutables The escrow immutable parameters\n     * @return escrow Address of the deployed escrow\n     */\n    function deploySrc(\n        IBaseEscrow.Immutables calldata immutables\n    ) external payable onlyOwner returns (address escrow) {\n        // Note: Caller must ensure msg.value covers amount + safety deposit + creation fee\n        // The factory will validate the fee payment\n\n        // Set deployedAt timestamp\n        IBaseEscrow.Immutables memory immutablesMem = immutables;\n        immutablesMem.timelocks = TimelocksLib.setDeployedAt(immutables.timelocks, block.timestamp);\n\n        // Calculate escrow address before deployment\n        escrow = _FACTORY.addressOfEscrowSrc(immutablesMem);\n\n        // Create the source escrow\n        _FACTORY.createSrcEscrow{value: msg.value}(immutablesMem);\n\n        emit SrcEscrowDeployed(escrow, immutables.orderHash, immutables.hashlock);\n    }\n\n    /**\n     * @notice Deploy a destination escrow (STX → EVM direction)\n     * @dev Called by resolver bot after detecting STX-side lock\n     * @param dstImmutables The destination escrow immutable parameters\n     * @return escrow Address of the deployed escrow\n     */\n    function deployDst(\n        IBaseEscrow.Immutables calldata dstImmutables\n    ) external payable onlyOwner returns (address escrow) {\n        // Calculate escrow address before deployment\n        escrow = _FACTORY.addressOfEscrowDst(dstImmutables);\n\n        // Create the destination escrow\n        _FACTORY.createDstEscrow{value: msg.value}(dstImmutables);\n\n        emit DstEscrowDeployed(escrow, dstImmutables.orderHash, dstImmutables.hashlock);\n    }\n\n    /**\n     * @notice Withdraw tokens from an escrow using the secret\n     * @dev Called by resolver bot after secret is revealed\n     * @param escrow Address of the escrow to withdraw from\n     * @param secret The revealed preimage (must hash to hashlock)\n     * @param immutables The escrow immutable parameters (for validation)\n     */\n    function withdraw(\n        IEscrow escrow,\n        bytes32 secret,\n        IBaseEscrow.Immutables calldata immutables\n    ) external onlyOwner {\n        escrow.withdraw(secret, immutables);\n        emit ResolverWithdraw(address(escrow), secret);\n    }\n\n    /**\n     * @notice Cancel an escrow and refund tokens\n     * @dev Called by resolver bot after timeout expires\n     * @param escrow Address of the escrow to cancel\n     * @param immutables The escrow immutable parameters (for validation)\n     */\n    function cancel(\n        IEscrow escrow,\n        IBaseEscrow.Immutables calldata immutables\n    ) external onlyOwner {\n        escrow.cancel(immutables);\n        emit ResolverCancel(address(escrow));\n    }\n\n    /**\n     * @notice Execute arbitrary calls (for advanced operations)\n     * @dev Allows owner to call any contract with any data\n     * @param targets Array of contract addresses to call\n     * @param arguments Array of calldata for each target\n     */\n    function arbitraryCalls(\n        address[] calldata targets,\n        bytes[] calldata arguments\n    ) external onlyOwner {\n        uint256 length = targets.length;\n        if (targets.length != arguments.length) revert LengthMismatch();\n\n        for (uint256 i = 0; i < length; ++i) {\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory returnData) = targets[i].call(arguments[i]);\n            if (!success) {\n                // Forward revert reason\n                if (returnData.length > 0) {\n                    assembly {\n                        let returnDataSize := mload(returnData)\n                        revert(add(32, returnData), returnDataSize)\n                    }\n                } else {\n                    revert(\"Arbitrary call failed\");\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraw ETH from the contract\n     * @dev Allows owner to withdraw any accumulated ETH\n     * @param to Address to send ETH to\n     * @param amount Amount of ETH to withdraw\n     */\n    function withdrawETH(address payable to, uint256 amount) external onlyOwner {\n        (bool success, ) = to.call{value: amount}(\"\");\n        require(success, \"ETH transfer failed\");\n    }\n\n    /**\n     * @notice Get the factory address\n     * @return Address of the STXEscrowFactory\n     */\n    function getFactory() external view returns (address) {\n        return address(_FACTORY);\n    }\n}\n"
      }
    }
  }
}